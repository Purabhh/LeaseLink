var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// server/external-apis.ts
var external_apis_exports = {};
__export(external_apis_exports, {
  GoogleMapsService: () => GoogleMapsService
});
var GoogleMapsService;
var init_external_apis = __esm({
  "server/external-apis.ts"() {
    "use strict";
    GoogleMapsService = class {
      static async validateAddress(address) {
        const apiKey = process.env.GOOGLE_MAPS_API_KEY;
        if (!apiKey) {
          console.log("Google Maps API key not configured, skipping validation");
          return { isValid: true, coordinates: null, formattedAddress: null };
        }
        try {
          const response = await fetch(
            `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${apiKey}`
          );
          if (!response.ok) {
            throw new Error(`Google Maps API error: ${response.status}`);
          }
          const data = await response.json();
          return {
            isValid: data.status === "OK" && data.results.length > 0,
            coordinates: data.results[0]?.geometry?.location || null,
            formattedAddress: data.results[0]?.formatted_address || null
          };
        } catch (error) {
          console.error("Google Maps API error:", error);
          throw error;
        }
      }
    };
  }
});

// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";
import { WebSocketServer, WebSocket } from "ws";

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  insertMatchSchema: () => insertMatchSchema,
  insertMessageSchema: () => insertMessageSchema,
  insertPropertySchema: () => insertPropertySchema,
  insertSwipeSchema: () => insertSwipeSchema,
  insertUserSchema: () => insertUserSchema,
  matches: () => matches,
  matchesRelations: () => matchesRelations,
  messages: () => messages,
  messagesRelations: () => messagesRelations,
  properties: () => properties,
  propertiesRelations: () => propertiesRelations,
  sessions: () => sessions,
  swipes: () => swipes,
  swipesRelations: () => swipesRelations,
  users: () => users,
  usersRelations: () => usersRelations
});
import {
  pgTable,
  text,
  varchar,
  timestamp,
  jsonb,
  index,
  integer,
  boolean,
  decimal,
  uuid
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { relations } from "drizzle-orm";
var sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull()
  },
  (table) => [index("IDX_session_expire").on(table.expire)]
);
var users = pgTable("users", {
  id: varchar("id").primaryKey().notNull(),
  email: varchar("email").unique(),
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  profileImageUrl: varchar("profile_image_url"),
  userType: varchar("user_type").notNull().default("buyer"),
  // "buyer" or "landlord"
  monthlyIncome: integer("monthly_income"),
  creditScore: integer("credit_score"),
  budgetMin: integer("budget_min"),
  budgetMax: integer("budget_max"),
  preferredZipCodes: text("preferred_zip_codes").array(),
  preferredBedrooms: integer("preferred_bedrooms"),
  preferredBathrooms: integer("preferred_bathrooms"),
  petFriendly: boolean("pet_friendly").default(false),
  moveInDate: timestamp("move_in_date"),
  phone: varchar("phone"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var properties = pgTable("properties", {
  id: uuid("id").primaryKey().defaultRandom(),
  landlordId: varchar("landlord_id").notNull().references(() => users.id),
  title: varchar("title").notNull(),
  address: text("address").notNull(),
  zipCode: varchar("zip_code").notNull(),
  latitude: decimal("latitude"),
  longitude: decimal("longitude"),
  price: integer("price").notNull(),
  bedrooms: integer("bedrooms").notNull(),
  bathrooms: decimal("bathrooms").notNull(),
  squareFootage: integer("square_footage"),
  leaseTerms: varchar("lease_terms"),
  moveInDate: timestamp("move_in_date"),
  amenities: text("amenities").array(),
  description: text("description"),
  images: text("images").array(),
  minCreditScore: integer("min_credit_score"),
  autoReject: boolean("auto_reject").default(false),
  isActive: boolean("is_active").default(true),
  marketEstimateMin: integer("market_estimate_min"),
  marketEstimateMax: integer("market_estimate_max"),
  daysOnMarket: integer("days_on_market"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var swipes = pgTable("swipes", {
  id: uuid("id").primaryKey().defaultRandom(),
  buyerId: varchar("buyer_id").notNull().references(() => users.id),
  propertyId: uuid("property_id").notNull().references(() => properties.id),
  direction: varchar("direction").notNull(),
  // "left" or "right"
  createdAt: timestamp("created_at").defaultNow()
});
var matches = pgTable("matches", {
  id: uuid("id").primaryKey().defaultRandom(),
  buyerId: varchar("buyer_id").notNull().references(() => users.id),
  landlordId: varchar("landlord_id").notNull().references(() => users.id),
  propertyId: uuid("property_id").notNull().references(() => properties.id),
  status: varchar("status").notNull().default("pending"),
  // "pending", "approved", "rejected"
  createdAt: timestamp("created_at").defaultNow()
});
var messages = pgTable("messages", {
  id: uuid("id").primaryKey().defaultRandom(),
  matchId: uuid("match_id").notNull().references(() => matches.id),
  senderId: varchar("sender_id").notNull().references(() => users.id),
  content: text("content").notNull(),
  createdAt: timestamp("created_at").defaultNow()
});
var usersRelations = relations(users, ({ many }) => ({
  properties: many(properties),
  swipes: many(swipes),
  buyerMatches: many(matches, { relationName: "buyerMatches" }),
  landlordMatches: many(matches, { relationName: "landlordMatches" }),
  messages: many(messages)
}));
var propertiesRelations = relations(properties, ({ one, many }) => ({
  landlord: one(users, {
    fields: [properties.landlordId],
    references: [users.id]
  }),
  swipes: many(swipes),
  matches: many(matches)
}));
var swipesRelations = relations(swipes, ({ one }) => ({
  buyer: one(users, {
    fields: [swipes.buyerId],
    references: [users.id]
  }),
  property: one(properties, {
    fields: [swipes.propertyId],
    references: [properties.id]
  })
}));
var matchesRelations = relations(matches, ({ one, many }) => ({
  buyer: one(users, {
    fields: [matches.buyerId],
    references: [users.id],
    relationName: "buyerMatches"
  }),
  landlord: one(users, {
    fields: [matches.landlordId],
    references: [users.id],
    relationName: "landlordMatches"
  }),
  property: one(properties, {
    fields: [matches.propertyId],
    references: [properties.id]
  }),
  messages: many(messages)
}));
var messagesRelations = relations(messages, ({ one }) => ({
  match: one(matches, {
    fields: [messages.matchId],
    references: [matches.id]
  }),
  sender: one(users, {
    fields: [messages.senderId],
    references: [users.id]
  })
}));
var insertUserSchema = createInsertSchema(users).omit({
  createdAt: true,
  updatedAt: true
});
var insertPropertySchema = createInsertSchema(properties).omit({
  id: true,
  landlordId: true,
  createdAt: true,
  updatedAt: true
}).extend({
  bathrooms: z.union([z.string(), z.number()]).transform((val) => {
    if (typeof val === "number") return val.toString();
    return val;
  }),
  moveInDate: z.union([z.string(), z.date()]).optional().transform((val) => {
    if (typeof val === "string") {
      return val === "" ? void 0 : new Date(val);
    }
    return val;
  }),
  squareFootage: z.number().optional(),
  leaseTerms: z.string().optional(),
  description: z.string().optional(),
  amenities: z.array(z.string()).optional(),
  images: z.array(z.string()).optional(),
  minCreditScore: z.number().optional(),
  autoReject: z.boolean().optional(),
  marketEstimateMin: z.number().optional(),
  marketEstimateMax: z.number().optional(),
  daysOnMarket: z.number().optional()
});
var insertSwipeSchema = createInsertSchema(swipes).omit({
  id: true,
  createdAt: true
});
var insertMatchSchema = createInsertSchema(matches).omit({
  id: true,
  createdAt: true
});
var insertMessageSchema = createInsertSchema(messages).omit({
  id: true,
  createdAt: true
});

// server/db.ts
import { neon } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-http";
if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?"
  );
}
var sql = neon(process.env.DATABASE_URL);
var db = drizzle(sql, { schema: schema_exports });

// server/storage.ts
import { eq, and, desc, asc } from "drizzle-orm";
var DatabaseStorage = class {
  // User operations
  async getUser(id) {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }
  async getUserByEmail(email) {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user;
  }
  async updateUserProfile(id, updates) {
    const [updatedUser] = await db.update(users).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(users.id, id)).returning();
    return updatedUser;
  }
  async upsertUser(userData) {
    const [user] = await db.insert(users).values(userData).onConflictDoUpdate({
      target: users.email,
      set: {
        firstName: userData.firstName,
        lastName: userData.lastName,
        profileImageUrl: userData.profileImageUrl,
        updatedAt: /* @__PURE__ */ new Date()
      }
    }).returning();
    return user;
  }
  // Property operations
  async createProperty(property) {
    const [newProperty] = await db.insert(properties).values(property).returning();
    return newProperty;
  }
  async getProperty(id) {
    const [property] = await db.select().from(properties).where(eq(properties.id, id));
    return property;
  }
  async getPropertiesByLandlord(landlordId) {
    return await db.select().from(properties).where(eq(properties.landlordId, landlordId)).orderBy(desc(properties.createdAt));
  }
  async getActiveProperties(filters) {
    let query = db.select().from(properties).where(eq(properties.isActive, true));
    return await query.orderBy(desc(properties.createdAt));
  }
  async updateProperty(id, updates) {
    const [updatedProperty] = await db.update(properties).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(properties.id, id)).returning();
    return updatedProperty;
  }
  async deleteProperty(id) {
    const propertyMatches = await db.select({ id: matches.id }).from(matches).where(eq(matches.propertyId, id));
    for (const match of propertyMatches) {
      await db.delete(messages).where(eq(messages.matchId, match.id));
    }
    await db.delete(matches).where(eq(matches.propertyId, id));
    await db.delete(swipes).where(eq(swipes.propertyId, id));
    await db.delete(properties).where(eq(properties.id, id));
  }
  // Swipe operations
  async createSwipe(swipe) {
    const [newSwipe] = await db.insert(swipes).values(swipe).returning();
    return newSwipe;
  }
  async getSwipesByBuyer(buyerId) {
    return await db.select().from(swipes).where(eq(swipes.buyerId, buyerId)).orderBy(desc(swipes.createdAt));
  }
  async getSwipesByProperty(propertyId) {
    return await db.select().from(swipes).where(eq(swipes.propertyId, propertyId)).orderBy(desc(swipes.createdAt));
  }
  async hasUserSwipedOnProperty(buyerId, propertyId) {
    const [swipe] = await db.select().from(swipes).where(and(
      eq(swipes.buyerId, buyerId),
      eq(swipes.propertyId, propertyId)
    ));
    return !!swipe;
  }
  // Match operations
  async createMatch(match) {
    const [newMatch] = await db.insert(matches).values(match).returning();
    return newMatch;
  }
  async getMatchesByBuyer(buyerId) {
    return await db.select().from(matches).where(eq(matches.buyerId, buyerId)).orderBy(desc(matches.createdAt));
  }
  async getMatchesByLandlord(landlordId) {
    return await db.select().from(matches).where(eq(matches.landlordId, landlordId)).orderBy(desc(matches.createdAt));
  }
  async getMatch(id) {
    const [match] = await db.select().from(matches).where(eq(matches.id, id));
    return match;
  }
  async updateMatchStatus(id, status) {
    const [updatedMatch] = await db.update(matches).set({ status }).where(eq(matches.id, id)).returning();
    return updatedMatch;
  }
  async getPendingMatchesForProperty(propertyId) {
    return await db.select().from(matches).where(and(
      eq(matches.propertyId, propertyId),
      eq(matches.status, "pending")
    )).orderBy(desc(matches.createdAt));
  }
  async getMatchesByProperty(propertyId) {
    return await db.select().from(matches).where(eq(matches.propertyId, propertyId)).orderBy(desc(matches.createdAt));
  }
  // Message operations
  async createMessage(message) {
    const [newMessage] = await db.insert(messages).values(message).returning();
    return newMessage;
  }
  async getMessagesByMatch(matchId) {
    return await db.select().from(messages).where(eq(messages.matchId, matchId)).orderBy(asc(messages.createdAt));
  }
};
var storage = new DatabaseStorage();

// server/googleAuth.ts
import passport from "passport";
import { Strategy as GoogleStrategy } from "passport-google-oauth20";
import session from "express-session";
import connectPg from "connect-pg-simple";
var GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID || "dummy-client-id";
var GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET || "dummy-client-secret";
if (!process.env.GOOGLE_CLIENT_ID || !process.env.GOOGLE_CLIENT_SECRET) {
  console.warn("\u26A0\uFE0F  Google OAuth credentials not found. Using dummy values for development.");
  console.warn("   Set GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET for production.");
}
function getSession() {
  const sessionTtl = 7 * 24 * 60 * 60 * 1e3;
  const pgStore = connectPg(session);
  const sessionStore = new pgStore({
    conString: process.env.DATABASE_URL,
    createTableIfMissing: false,
    ttl: sessionTtl,
    tableName: "sessions"
  });
  return session({
    secret: process.env.SESSION_SECRET || "your-session-secret-here",
    store: sessionStore,
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      maxAge: sessionTtl
    }
  });
}
async function setupAuth(app2) {
  app2.set("trust proxy", 1);
  app2.use(getSession());
  app2.use(passport.initialize());
  app2.use(passport.session());
  const callbackURL = process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}/api/auth/google/callback` : "/api/auth/google/callback";
  passport.use(new GoogleStrategy(
    {
      clientID: GOOGLE_CLIENT_ID,
      clientSecret: GOOGLE_CLIENT_SECRET,
      callbackURL
    },
    async (accessToken, refreshToken, profile, done) => {
      try {
        const email = profile.emails?.[0]?.value || "";
        let user = await storage.getUserByEmail(email);
        if (user) {
          const updatedUser = await storage.updateUserProfile(user.id, {
            firstName: profile.name?.givenName || user.firstName,
            lastName: profile.name?.familyName || user.lastName,
            profileImageUrl: profile.photos?.[0]?.value || user.profileImageUrl
          });
          return done(null, updatedUser);
        } else {
          const userData = {
            id: profile.id,
            email,
            firstName: profile.name?.givenName || "",
            lastName: profile.name?.familyName || "",
            profileImageUrl: profile.photos?.[0]?.value || null
          };
          const newUser = await storage.upsertUser(userData);
          return done(null, newUser);
        }
      } catch (error) {
        console.error("Google OAuth error:", error);
        return done(error, void 0);
      }
    }
  ));
  passport.serializeUser((user, done) => {
    done(null, user.id);
  });
  passport.deserializeUser(async (id, done) => {
    try {
      const user = await storage.getUser(id);
      done(null, user);
    } catch (error) {
      done(error, null);
    }
  });
  app2.get(
    "/api/auth/google",
    passport.authenticate("google", { scope: ["profile", "email"] })
  );
  app2.get(
    "/api/auth/google/callback",
    passport.authenticate("google", { failureRedirect: "/login-failed" }),
    (req, res) => {
      res.redirect("/");
    }
  );
  app2.get("/api/logout", (req, res) => {
    req.logout((err) => {
      if (err) {
        return res.status(500).json({ message: "Logout failed" });
      }
      res.redirect("/");
    });
  });
}
var isAuthenticated = async (req, res, next) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  next();
};

// server/aiRecommendations.ts
import OpenAI from "openai";
var openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
var AIRecommendationService = class {
  static async generateRecommendations(user, properties2, userSwipes = []) {
    if (!properties2.length) return properties2;
    try {
      const preferences = this.extractUserPreferences(user);
      const swipeInsights = this.analyzeSwipeHistory(userSwipes, properties2);
      const scoredProperties = await this.scoreProperties(
        preferences,
        properties2,
        swipeInsights
      );
      return this.sortPropertiesByScore(properties2, scoredProperties);
    } catch (error) {
      console.error("AI recommendation error:", error);
      return properties2;
    }
  }
  static extractUserPreferences(user) {
    return {
      budget: {
        min: user.budgetMin || 0,
        max: user.budgetMax || 999999
      },
      location: user.preferredZipCodes || [],
      bedrooms: user.preferredBedrooms,
      bathrooms: user.preferredBathrooms,
      petFriendly: user.petFriendly || false,
      lifestyle: this.inferLifestyle(user)
    };
  }
  static inferLifestyle(user) {
    const income = user.monthlyIncome || 0;
    const creditScore = user.creditScore || 0;
    if (income > 8e3 && creditScore > 750) return "luxury";
    if (income > 5e3 && creditScore > 700) return "professional";
    if (income > 3e3) return "moderate";
    return "budget-conscious";
  }
  static analyzeSwipeHistory(swipes2, properties2) {
    if (!swipes2.length) return "No previous swipe history";
    const likes = swipes2.filter((s) => s.direction === "right");
    const dislikes = swipes2.filter((s) => s.direction === "left");
    if (!likes.length) return "No liked properties yet";
    const likedProperties = properties2.filter(
      (p) => likes.some((like) => like.propertyId === p.id)
    );
    const avgLikedPrice = likedProperties.reduce((sum, p) => sum + p.price, 0) / likedProperties.length;
    const commonBedrooms = this.getMostCommon(likedProperties.map((p) => p.bedrooms));
    const commonAmenities = this.getMostCommonAmenities(likedProperties);
    return `User tends to like properties around $${avgLikedPrice.toFixed(0)}, ${commonBedrooms} bedrooms, with amenities: ${commonAmenities.join(", ")}`;
  }
  static getMostCommon(array) {
    const counts = array.reduce((acc, item) => {
      acc[item] = (acc[item] || 0) + 1;
      return acc;
    }, {});
    return Object.keys(counts).reduce(
      (a, b) => counts[a] > counts[b] ? a : b
    );
  }
  static getMostCommonAmenities(properties2) {
    const allAmenities = properties2.flatMap((p) => p.amenities || []);
    const counts = allAmenities.reduce((acc, amenity) => {
      acc[amenity] = (acc[amenity] || 0) + 1;
      return acc;
    }, {});
    return Object.entries(counts).sort(([, a], [, b]) => b - a).slice(0, 3).map(([amenity]) => amenity);
  }
  static async scoreProperties(preferences, properties2, swipeInsights) {
    const propertyData = properties2.map((p) => ({
      id: p.id,
      title: p.title,
      price: p.price,
      bedrooms: p.bedrooms,
      bathrooms: p.bathrooms,
      zipCode: p.zipCode,
      amenities: p.amenities || [],
      address: p.address
    }));
    const prompt = `
You are a real estate recommendation AI. Score properties from 1-100 based on user preferences and behavior.

User Preferences:
- Budget: $${preferences.budget.min} - $${preferences.budget.max}
- Preferred locations: ${preferences.location.join(", ") || "Any"}
- Bedrooms: ${preferences.bedrooms || "Any"}
- Bathrooms: ${preferences.bathrooms || "Any"}
- Pet friendly: ${preferences.petFriendly}
- Lifestyle: ${preferences.lifestyle}

User Behavior Insights:
${swipeInsights}

Properties to score:
${JSON.stringify(propertyData, null, 2)}

Return a JSON array of objects with propertyId, score (1-100), and brief reasoning.
Focus on: budget fit, location match, size preferences, lifestyle compatibility, and past behavior patterns.

Format: [{"propertyId": "id", "score": 85, "reasoning": "Perfect budget fit, matches preferred area"}]
`;
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: "You are a real estate recommendation expert. Provide property scores in valid JSON format only."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      response_format: { type: "json_object" },
      temperature: 0.3
    });
    const result = JSON.parse(response.choices[0].message.content || "[]");
    return Array.isArray(result) ? result : result.scores || [];
  }
  static sortPropertiesByScore(properties2, scores) {
    const scoreMap = new Map(scores.map((s) => [s.propertyId, s.score]));
    return properties2.map((property) => ({
      property,
      score: scoreMap.get(property.id) || 50
      // Default score if not found
    })).sort((a, b) => b.score - a.score).map((item) => item.property);
  }
};

// server/routes.ts
import { z as z2 } from "zod";
async function registerRoutes(app2) {
  await setupAuth(app2);
  app2.get("/api/auth/user", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });
  app2.get("/api/users/:id", isAuthenticated, async (req, res) => {
    try {
      const userId = req.params.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });
  app2.patch("/api/user/profile", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const updateData = req.body;
      console.log("Updating user profile:", userId, "with data:", updateData);
      const updatedUser = await storage.updateUserProfile(userId, updateData);
      console.log("Profile updated successfully:", updatedUser);
      res.json(updatedUser);
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ message: "Failed to update profile" });
    }
  });
  app2.get("/api/properties", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const swipedProperties = await storage.getSwipesByBuyer(userId);
      const swipedPropertyIds = swipedProperties.map((swipe) => swipe.propertyId);
      const allProperties = await storage.getActiveProperties();
      const availableProperties = allProperties.filter(
        (prop) => !swipedPropertyIds.includes(prop.id) && prop.landlordId !== userId
      );
      const recommendedProperties = await AIRecommendationService.generateRecommendations(
        user,
        availableProperties,
        swipedProperties
      );
      const propertiesWithInterestedCount = await Promise.all(
        recommendedProperties.map(async (property) => {
          const propertyMatches = await storage.getMatchesByProperty(property.id);
          const interestedCount = propertyMatches.filter(
            (match) => match.status === "pending" || match.status === "approved"
          ).length;
          return {
            ...property,
            interestedCount
          };
        })
      );
      res.json(propertiesWithInterestedCount);
    } catch (error) {
      console.error("Error fetching properties:", error);
      res.status(500).json({ message: "Failed to fetch properties" });
    }
  });
  app2.post("/api/properties", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      console.log("Creating property for user:", userId);
      console.log("Request body:", req.body);
      const validatedData = insertPropertySchema.parse(req.body);
      let addressValidation = { isValid: true, coordinates: null, formattedAddress: null };
      try {
        const { GoogleMapsService: GoogleMapsService2 } = await Promise.resolve().then(() => (init_external_apis(), external_apis_exports));
        const fullAddress = `${validatedData.address}, ${validatedData.zipCode}`;
        addressValidation = await GoogleMapsService2.validateAddress(fullAddress);
        if (!addressValidation.isValid) {
          return res.status(400).json({
            message: "Location not found. Please check the address and ZIP code.",
            field: "address"
          });
        }
        console.log("Address validated successfully:", addressValidation.formattedAddress);
      } catch (error) {
        console.log("Address validation skipped:", error.message);
      }
      const propertyData = {
        ...validatedData,
        landlordId: userId
      };
      if (addressValidation.coordinates) {
        propertyData.latitude = addressValidation.coordinates.lat.toString();
        propertyData.longitude = addressValidation.coordinates.lng.toString();
      }
      if (addressValidation.formattedAddress) {
        propertyData.address = addressValidation.formattedAddress;
      }
      console.log("Parsed property data:", propertyData);
      const newProperty = await storage.createProperty(propertyData);
      res.json(newProperty);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        console.error("Property validation errors:", error.errors);
        return res.status(400).json({ message: "Invalid property data", errors: error.errors });
      }
      console.error("Error creating property:", error);
      res.status(500).json({ message: "Failed to create property" });
    }
  });
  app2.get("/api/properties/my", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const properties2 = await storage.getPropertiesByLandlord(userId);
      res.json(properties2);
    } catch (error) {
      console.error("Error fetching user properties:", error);
      res.status(500).json({ message: "Failed to fetch properties" });
    }
  });
  app2.patch("/api/properties/:id", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const propertyId = req.params.id;
      const updates = req.body;
      if (updates.moveInDate === "") {
        updates.moveInDate = null;
      } else if (updates.moveInDate && typeof updates.moveInDate === "string") {
        updates.moveInDate = new Date(updates.moveInDate);
      }
      const property = await storage.getProperty(propertyId);
      if (!property || property.landlordId !== userId) {
        return res.status(404).json({ message: "Property not found" });
      }
      const updatedProperty = await storage.updateProperty(propertyId, updates);
      res.json(updatedProperty);
    } catch (error) {
      console.error("Error updating property:", error);
      res.status(500).json({ message: "Failed to update property" });
    }
  });
  app2.delete("/api/properties/:id", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const propertyId = req.params.id;
      const property = await storage.getProperty(propertyId);
      if (!property || property.landlordId !== userId) {
        return res.status(404).json({ message: "Property not found" });
      }
      await storage.deleteProperty(propertyId);
      res.json({ message: "Property deleted successfully" });
    } catch (error) {
      console.error("Error deleting property:", error);
      res.status(500).json({ message: "Failed to delete property" });
    }
  });
  app2.post("/api/swipes", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const { propertyId, direction } = req.body;
      const hasSwipedBefore = await storage.hasUserSwipedOnProperty(userId, propertyId);
      if (hasSwipedBefore) {
        return res.status(400).json({ message: "Already swiped on this property" });
      }
      const swipeData = insertSwipeSchema.parse({
        buyerId: userId,
        propertyId,
        direction
      });
      const newSwipe = await storage.createSwipe(swipeData);
      if (direction === "right") {
        const property = await storage.getProperty(propertyId);
        if (property) {
          const matchData = insertMatchSchema.parse({
            buyerId: userId,
            landlordId: property.landlordId,
            propertyId,
            status: "pending"
          });
          const newMatch = await storage.createMatch(matchData);
          return res.json({ swipe: newSwipe, match: newMatch });
        }
      }
      res.json({ swipe: newSwipe });
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid swipe data", errors: error.errors });
      }
      console.error("Error creating swipe:", error);
      res.status(500).json({ message: "Failed to create swipe" });
    }
  });
  app2.get("/api/matches", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      let matches2;
      if (user.userType === "landlord") {
        matches2 = await storage.getMatchesByLandlord(userId);
      } else {
        matches2 = await storage.getMatchesByBuyer(userId);
      }
      res.json(matches2);
    } catch (error) {
      console.error("Error fetching matches:", error);
      res.status(500).json({ message: "Failed to fetch matches" });
    }
  });
  app2.patch("/api/matches/:id/status", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const matchId = req.params.id;
      const { status } = req.body;
      const match = await storage.getMatch(matchId);
      if (!match || match.landlordId !== userId) {
        return res.status(404).json({ message: "Match not found" });
      }
      const updatedMatch = await storage.updateMatchStatus(matchId, status);
      res.json(updatedMatch);
    } catch (error) {
      console.error("Error updating match status:", error);
      res.status(500).json({ message: "Failed to update match status" });
    }
  });
  app2.get("/api/properties/:id/pending-matches", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const propertyId = req.params.id;
      const property = await storage.getProperty(propertyId);
      if (!property || property.landlordId !== userId) {
        return res.status(404).json({ message: "Property not found" });
      }
      const pendingMatches = await storage.getPendingMatchesForProperty(propertyId);
      res.json(pendingMatches);
    } catch (error) {
      console.error("Error fetching pending matches:", error);
      res.status(500).json({ message: "Failed to fetch pending matches" });
    }
  });
  app2.get("/api/matches/:id/messages", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const matchId = req.params.id;
      const match = await storage.getMatch(matchId);
      if (!match || match.buyerId !== userId && match.landlordId !== userId) {
        return res.status(404).json({ message: "Match not found" });
      }
      const messages2 = await storage.getMessagesByMatch(matchId);
      res.json(messages2);
    } catch (error) {
      console.error("Error fetching messages:", error);
      res.status(500).json({ message: "Failed to fetch messages" });
    }
  });
  const httpServer = createServer(app2);
  const wss = new WebSocketServer({ server: httpServer, path: "/ws" });
  wss.on("connection", (ws, req) => {
    console.log("New WebSocket connection");
    ws.on("message", async (data) => {
      try {
        const messageData = JSON.parse(data.toString());
        if (messageData.type === "chat_message") {
          const { matchId, content, senderId } = messageData;
          const match = await storage.getMatch(matchId);
          if (!match || match.buyerId !== senderId && match.landlordId !== senderId) {
            ws.send(JSON.stringify({ type: "error", message: "Unauthorized" }));
            return;
          }
          const newMessage = await storage.createMessage({
            matchId,
            senderId,
            content
          });
          const broadcastData = JSON.stringify({
            type: "new_message",
            message: newMessage
          });
          wss.clients.forEach((client) => {
            if (client.readyState === WebSocket.OPEN) {
              client.send(broadcastData);
            }
          });
        }
      } catch (error) {
        console.error("WebSocket message error:", error);
        ws.send(JSON.stringify({ type: "error", message: "Invalid message format" }));
      }
    });
    ws.on("close", () => {
      console.log("WebSocket connection closed");
    });
  });
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
var vite_config_default = defineConfig({
  plugins: [
    react()
    // Standard error overlay is built into Vite - no need for external plugins
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"]
    },
    // Built-in error overlay configuration
    hmr: {
      overlay: true
      // Shows compilation errors as overlay
    }
  },
  // Enhanced error reporting
  esbuild: {
    logOverride: { "this-is-undefined-in-esm": "silent" }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express2();
app.use(express2.json({ limit: "50mb" }));
app.use(express2.urlencoded({ extended: false, limit: "50mb" }));
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = 5e3;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();